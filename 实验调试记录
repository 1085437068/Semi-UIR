1.数据集制作：参考readme
（1）选择一个数据集UIEB, EUVP, UWCNN, Sea-thru, RUIE，使用data_split.py将数据集分成readme中要求的格式
（2）LA文件夹数据使用estimate_illumination.py生成
（3）candidate文件夹数据使用create_candidate.py生成

2.运行test
虚拟环境pt181：
pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html
（1）需要在系统安装cuda,不然mmcv无法安装  
--》 cuda cudnn安装方法https://blog.csdn.net/weixin_37926734/article/details/123033286?spm=1001.2014.3001.5506
(2)图片尺寸太大会爆显存，统一裁剪到320x320

3.运行train
(1)将 Image.ANTIALIAS 替换为 Image.Resampling.LANCZOS。Resampling.LANCZOS 是 ANTIALIAS 的替代品。例如：
        resized_a = A.resize((self.fineSize, self.fineSize), Image.Resampling.LANCZOS)
        resized_b = B.resize((self.fineSize, self.fineSize), Image.Resampling.LANCZOS)
        resized_c = C.resize((self.fineSize, self.fineSize), Image.Resampling.LANCZOS)
(2)问题（utils.py中）：ValueError: win_size exceeds image extent. Either ensure that your images are at least 7x7...
解决方法：修改为ssim += structural_similarity(clean[i], recoverd[i], data_range=1, multichannel=True, win_size=3)
(3)其他bug看git历史记录
(4)pyiqa安装会自动安装cpu版本，安装完pyiqa后需要再重新把GPU版本安装回来pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html
(5)问题：  
cum_counts = np.cumsum(np.greater(counts, 0, dtype=np.int32))
TypeError: No loop matching the specified signature and casting was found for ufunc greater
解决方法：在前面添加
counts = np.asarray(counts, dtype=np.float32)  # 或者 dtype=np.int32
if counts.size == 0:
    raise ValueError("Counts array is empty, cannot create histogram.")
（6）trainer.py将
        score_t = np.array([self.iqa_metric(teacher_predict[i].unsqueeze(0)).detach().cpu().numpy()for i in range(N)])
        score_s = np.array([self.iqa_metric(student_predict[i].unsqueeze(0)).detach().cpu().numpy()for i in range(N)])
        score_r = np.full(N, score_r)
修改为：
        score_t = np.array([self.iqa_metric(teacher_predict[i].unsqueeze(0)).detach().cpu().numpy()for i in range(N)])
        score_s = np.array([self.iqa_metric(student_predict[i].unsqueeze(0)).detach().cpu().numpy()for i in range(N)])
        score_r = np.full(N, score_r)
